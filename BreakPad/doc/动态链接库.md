# 动态链接库
又称动态库（.so文件）

共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程叫做动态链接，是由一个叫做动态链接器的程序来执行的。在Linux系统中通常用.so后缀来表示，在Windows系统中，用.dll后缀来表示，叫做动态链接库。

## 动态链接库和头文件的联系
在程序编译过程中，链接动态库是需要动态库的头文件，但在运行阶段就不再需要了。

头文件存在的用于就是告诉编译器 函数或者变量在其他.cpp文件中存在，编译器可以根据头文件的声明信息，去其他.cpp文件找到函数的具体定义。
因此，编译阶段，需要头文件来告诉编译器函数名称，然后取符号表中去找。

## 动态链接库的实现和使用
1. 编写头文件.h
```
//so_test.h
#include "stdio.h"

void test_a();
void test_b();
```
2. 编写.c/.cpp文件
```
//test_a.c
#include "so_test.h"
void test_a()
{
    printf("这里是test_a执行\n");
}
```
```
//test_b.c
#include "so_test.h"
void test_b()
{
    printf("这里是test_b执行\n");
}
```
3. 编译动态库libtest.so
```
$ gcc test_a.c test_b.c -fPIC -shared -o libtest.so
```

4. 动态链接库的使用
前面编译了一个动态库libtest.so，放在当前目录下，要使用它，可以包含动态库的头文件.h，并使用其中的函数。
```
// test.c
#include "so_test.h"
int main(){
    test_a();
    test_b();
    return 0;
}
```
// 要使用动态库，在程序源代码编译为可执行文件的编译阶段时，进行动态库库的链接。
```
gcc test.c -L. -ltest -o test
```
这就连接了动态库libtest.so并使用到其库函数，经过gcc编译test.c生成test可执行文件。
## 动态编译
GCC命令执行动态编译  
* -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
* -shared：该选项指定gcc编译器生成动态连接库，而不是可执行文件。
* -L：指定编译的时候动态链接库的位置，这里使用 -L. 后面跟了一个点表示要连接的库在当前目录中
* LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。
* -ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称.

__注：静态编译和动态编译有区别，例如输入选项gcc test.c -o test -L. -ltest,编译器会在当前目录下寻找lib test .so文件，也就是会自动填补库文件名称。而对于静态库则是补充lib hello .a进行匹配寻找。例子：gcc hello.c -o hello -static -L. -lhello__

__注：执行使用动态链接库生成的可执行程序容易出现找不到动态库的情况，通常程序执行会去/lib或者/usr/lib下去找，这里是找库的默认路径，如果动态库放在其他目录下，要编辑/etc/ld.so.conf 文件,在其中添加上新生成的要使用的动态库的路劲，然后运行ldconfig命令，重建/etc/ld.so.cache文件__

## 库文件
1. 本质是啥  
本质上一种可执行代码的二进制形式文件，可以被操作系统载入内存。由于linux和window的（编译器、汇编器、连接器的不同），二者的库文件是不兼容的。

2. Linux库文件的种类  
二者的不同点在于代码被载入的时刻不同。  
静态库文件.a后缀，在程序编译阶段就会被载入可执行程序，这样生成的可执行程序体积会较大。  
动态库文件.so后缀，可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。  
生成动态库使用gcc完成，生成静态库使用ar工具生成。
```
$ gcc -c hello.c -o hello.o  //先用gcc编译生成.o，.o文件是链接文件，
                            //.a是静态库文件，靠.o文件生成，作为一个库为外部程序提供函数，接口,
                            //一个.c或.cpp文件对应一个.o文件
$ ar cqs libhello.a hello.o  //ar生成静态库文件libhello.a
```
__此外，动态库还有一个好处是多个程序调用同一个动态库时，在系统内存中，只要加载一份该库的实例即可。__    
__库的版本控制，在库文件后面添加版本号，使用建立符号连接的方式。__  
__[库文件类别](https://blog.csdn.net/hnlgzb/article/details/120484079)__

## 